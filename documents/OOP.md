# Class
A class is user-defined type.<br>
A class can be described as data and functionality on that data wrapped into one. it consists of member fields and member function.<br>
An instance of class is called object.

```cpp
#include<iostream>
class MyClass{
  int x;
  public:
  void printX();
}
void MyClass::printX(){
  std::cout << x << "\n";
}
int main(){
  MyClass obj;
  obj.printX();
}
```
## visibility == accessbility
visibility from the perspective of three diff actors:<br>
1. A class itself : can access private, public and protected.
2. A derived class : can access public and protected
4. A object of a class : can access only public

>put then into `public:`<br>
If we want the class members to be accessible to object.
 
>put them into `protected:`:<br> Inheritance

> put them into `private:`<br>
if do not want class member to be accessible to object.

## Constructor : Initialize an object.
A Constructor is public member function that has same class name.<br>
Constructor purpose is initialize an object of a class.<br>
`when object is created, a code inside Constructor runs.` 
```cpp
class MyClass{
  ....
  public:
  MyClass(){ //default constructor
    std::cout << "Constructor";
  }
};
```
- Default Constructor<br>
A Constructor without parameter or with parameters set is called Default Constructor.<br>
if default constructor is not explicitly defined in the code, the compiler will generate
a default constructor but when we define a constructor of our own, default constructor is not generated by compiler.<br>
`constructor cann't be invoked directly.`<br>
`Member Initialization:`
```cpp
class MyClass{
  int x;
  int y;
  public:
  MyClass(int xx, int yy);
};
MyClass::MyClass(int xx, int yy):x{xx}, y{yy}{}
int main(){
  MyClass obj(1,2);
}
```
---
### Copy/Move object to another object
Shallow copy and Deep copy
- `Copy Constructor`<br>
When we initialize an object of the class with another object of the same class
we invoke copy constructor. if we do not provide compiler generate a default copy 
constructor that perform `Shallow copy`. `Initialize an object with another object`.
```cpp
class MyClass{
  int x;
  int y;
  public:
  MyClass(int xx, int yy) : x{xx}, y{yy}{}
};
int main(){
  MyClass obj1{1,2};
  MyClass obj2 = obj1; // default copy constructor invoked.
}
```
Copy Constructor `signature`<br>
`MyClass(const MyClass& rhs){}`
```cpp
class MyClass{
  int x;
  int y;
  public:
  MyClass(int xx, int yy) : x{xx}, y{yy}{}
  MyClass(const MyClass &rhs) : x{rhs.x}, y{rhs.y}{
    std::cout <<"User defined Copy constructor\n";
  }
};
int main(){
  MyClass obj1{1,2};
  MyClass obj2 = ob1; // user-defined copy constructor invoked
}
```
`Note:` Default copy constructor does not correctly copy members of some types
such as pointers, arrays etc. In order to make copies properly we need to define
our own logic inside the copy constructor. this is refered as `Deep Copy.` 
- `Copy Assignment : operator = overloading`<br>
Copy the values to an object `after it has been created/initialized.`<br>
Copy Assignment `signature`:<br>
`MyClass& operator=(const MyClass& rhs){}`
```cpp
class MyClass{
  int x;
  int y;
  public:
  //constructor
  MyClass(int xx, int yy) : x{xx}, y{yy}{} 
  //copy constructor
  MyClass(const MyClass &rhs) : x{rhs.x},y{rhs.y}{} 
  //copy assignment
  MyClass& operator=(const MyClass &rhs): x{rhs.x},y{rhs.y}{
    return *this;
  } 
};
int main(){
  MyClass obj1{1,2};
  MyClass obj2{2,3};
  MyClass obj3 = ob1 // Copy Constructor
  obj2 = obj1 //Copy Assignment
}
```
`Note`: Move semantic achived throgh Move Constructor/Assignment.
- `Move Constructor`<br>
Uses `std::move(object);`<br>
Compiler generates Default Move Constructor.<br>
The object from which data was moved is left in some valid but unspecified state.<br>
`Move operation is efficient in terms of speed of execution. as we do not have to make copies.`<br>
Move semantic accepts reference to that rvalue.<br>
Move constructor `signature`:<br>
`MyClass(MyClass &&rhs): x{std::move(rhs.x)}, s{std::move(rhs.s)}{}`



```cpp
class MyClass{
  int x;
  std::string s;
  public:
  MyClass(int xx, std::string ss) : x{xx}, s{ss}{}
  MyClass(MyClass &&rhs): x{std::move(rhs.x)}, s{std::move(rhs.s)}{}
};
int main(){
  MyClass obj1{1, "Ram"};
  MyClass obj2 = std::move(obj1); //Move constructor
}
```
- `Move Assignment`<br>
“The move assignment operator is invoked when we declare an object and then try to assign an rvalue reference to it”<br>
Move Assignment `signature`:<br>
`MyCass& operator=(MyCass &&rhs)`
```cpp
class MyClass{
  int x;
  std::string s;
  MyClass(int xx, std::string ss) : x{xx}, s{ss}{}
  MyClass& operator=(MyClass &&rhs){
    x = std::move(rhs.x);
    s = std::move(rhs.s);
    return *this;
  }
};
int main(){
  MyClass ob1{1, "obj1"};
  MyClass obj2{2, "obj2"};
  obj2 = std::move(obj1); //move assigment.
  
}

```


- `Destructors:`<br>
```cpp
class MyClass{
  private:
  int *p;
  public:
  MyClass() : p{new int{123}}{}
  ~MyClass(){
    delete p;
  }
};
int main(){
  MyClass obj; //construcor invoked
} //destructor invoked
```
“a destructor is a member function that gets invoked when an object is destroyed”
## Rule of five in C++
```cpp
#include<iostream>
#include<string.h>
#include<memory>

class Student
{
private:
    int id;
    std::unique_ptr<char> name;

public:
    Student()
    { // Student s;
        this->id = 0;
        this->name = nullptr;
    }
    Student(int id, char *name)
    { // Student s1{1, "John"}
        this->id = id;
        this->name = std::make_unique<char>(strlen(name) + 1);
        strcpy(this->name.get(), name);
    }
    ~Student(){}
    // Copy Constructor
    Student(const Student &rhs)
    { // Student s2 = s1;
        this->id = rhs.id;
        this->name = std::make_unique<char>(strlen(rhs.name.get()) + 1);
        strcpy(this->name.get(), rhs.name.get());
    }
    // Copy Assignment
    Student &operator=(const Student &rhs)
    { /* Student s3; s3 = s1; */
        // self assigment check
        if (this != &rhs)
        {
            this->id = rhs.id;
            // delete old data
            if (this->name)
            {
                delete[] this->name.get();
            }
            this->name = std::make_unique<char>(strlen(rhs.name.get()) + 1);
            strcpy(this->name.get(), rhs.name.get());
        }
        return *this;
    }
    // Move Constructor
    Student(Student &&rhs)
    { // Student s4{4, "Jane"}; Student s5 = std::move(s4);
        this->id = std::move(rhs.id);
        this->name = std::move(rhs.name);
        rhs.name = nullptr;
    }
    // Move assigment
    Student &operator=(Student &&rhs)
    { /* Student s6; s6 = std::move(s5); */
        // self assigment check
        if (this != &rhs)
        {
            this->id = std::move(rhs.id);
            // delete old data
            if (this->name)
            {
                delete[] this->name.get();
            }
            this->name = std::move(rhs.name);
            rhs.name = nullptr;
        }
        return *this;
    }
    void StudentDetails(){
        std::cout << "ID: " << this->id << "\n";
        std::cout << "Name: " << this->name << "\n";
    }
};
Student foo()
{
    Student s1{1, "Arnold"};
    return s1;
}

int main()
{
    Student s1{1, "John"}; // Constructor
    Student s2 = s1;       // Copy Constructor
    Student s3;
    s3 = s1; // Copy Assignment
    Student s4{4, "Jane"};
    Student s5 = std::move(s4); // Move Constructor
    Student s6;
    s6 = std::move(s5);          // Move Assignment
    Student someStudent = foo(); // Move Constructor => steal data from dying object s1 of foo().
    std::cout << "s1"
              << "\n";
    s1.StudentDetails();
    std::cout << "s2"
              << "\n";
    s2.StudentDetails();
    std::cout << "s3"
              << "\n";
    s3.StudentDetails();
    std::cout << "s4"
              << "\n";
    //s4.StudentDetails(); s4 is moved
    std::cout << "s5"
              << "\n";
    //s5.StudentDetails(); s5 is moved
    std::cout << "s6"
              << "\n";
    s6.StudentDetails();
}
```
## Operator overloading

### Exercise
1. “Write a program that overloads the arithmetic operator – in terms of a compound arithmetic operator -=. Subtract one object from the other and assign the result to a third object. Print out the values of the resulting object’s member fields.”
```cpp
/*
“Write a program that overloads the arithmetic operator – in terms of a compound 
arithmetic operator -=. Subtract one object from the other and assign the result
 to a third object. Print out the values of the resulting object’s member fields.”
*/

#include<iostream>
class MyClass{
    int x;
    public:
    MyClass(){
        this->x = 0;
    }
    MyClass(int xx) : x{xx}{}
    MyClass& operator-=(const MyClass &rhs){
        this->x -= rhs.x;
        return *this;
    }
    friend MyClass operator-(MyClass lhs, const MyClass &rhs){
        lhs -= rhs;
        return lhs;
    }
    void printValue(){
        std::cout << "x is " << x << "\n";
    }
};

int main(){
    MyClass a{90};
    MyClass b{5};
    MyClass c = b - a;
    c.printValue();
}
```

## Inheritance
we can build a class from exisiting class. A class can be derived from an exisiting
class. This is known as Inheritance.<br>
`class MyDrivedClass : public MyBaseClass {}`<br>
derived class can not access private members of base class.<br>
the derived class inherits public and protected base class members.<br>
the derived class is compatible with base class.<br>
a pointer to derived class is compatible with pointer to base class.
```cpp
class MyBaseClass{
  public:
  char c;
  int x;
}
class MyDerivedClass: public MyBaseClass{
  public:
  int d;
}
class MySecondDerviedClass: public MyDerivedClass{
  public:
  bool b;
}

int main(){
  MySecondDerivedClass obj;
  obj.c = 'c';
}
```
## Polymorphism
Polymorphism means object can morph into different types.<br>
Polymorphism is achieved throgh an interface known as virtual functions.<br>
A virtual functions is a function whose behaviour can be overriden in derived class.<br>
And our pointer/object morphs into different types to invoke appropriate function.<br>
virtual means this function can be overriden/redefined in subsequent derived class.
```cpp
#include<iostream>
#include<memory>
class MyBaseClass{
    public:
    virtual void doWork(){
        std::cout << "I'm from base class\n";
    }
    virtual ~MyBaseClass(){}
};
class MyDerivedClass : public MyBaseClass{
    public:
    void doWork(){
        std::cout << "I'm from derived class\n";
    }
};
int main(){
    std::shared_ptr<MyBaseClass> obj = std::make_shared<MyDerivedClass>();
    obj->doWork();
}
```
`Note:` -> operator dereferences a pointer to an object and accesses the member of class.
## Abstract class : pure virtual function
Pure virtual functions do not have definations and are called interfaces.<br>
Pure virtual functions must be redefined in base class<br>
Classes having atleast one pure virtual function are called `Abstract Class` and can not be instantiated.<br>
`Abstract Class` can only be used base class.
```cpp
#include<iostream>
#include<memory>
class MyAbstractClass{
    public:
        virtual void doWork() = 0;
        virtual ~MyAbstractClass(){}
};
class MyDerivedClass : public MyAbstractClass{
    public:
    void doWork(){
        std::cout << "I'm from Derived class\n";
    }
};
int main(){
    std::shared_ptr<MyAbstractClass> absobject = std::make_shared<MyDerivedClass>();
    absobject->doWork();
}
```
## Pillars of OOP
- `Encapsulation`<br>
Encapsulation is grouping the fields into different visibility zones.
- `Inheritance`<br>
Inheritance is creating a class from base class.
- `Polymorphism`<br>
Polymorphism is an ability of an object to morph into different types
during runtime, ensuring the proper function is invoked.<br>
this is achieved through `Inheritance`, `virtual and overriden functions`, and `base and derived class pointers`.

```cpp
/*
“Write a program that defines a base class called Person. The class has the following members:
    A data member of type std::string called the name
    A single-parameter, user-defined constructor which initializes the name
    A getter function of type std::string called getname(), which returns the name’s value
Then, write a class called Student, which inherits from the class Person. 
The class Student has the following members:
    An integer data member called the semester
    A user-provided constructor that initializes the name and semester fields
    A getter function of type int called getsemester(), which returns the semester’s value”
*/

#include<iostream>
#include<memory>
#include<string>
class Person{
    std::string name;
    public:
        Person(const std::string& name);
        virtual std::string getName();
        virtual int getSemester() const = 0;
};
class Student : public Person{
    int semester;
    public:
        Student(const int& semester, const std::string& name);
        int getSemester() const;
};

Person::Person(const std::string& name):name{name}{}
Student::Student(const int& semester, const std::string& name) : semester{semester}, Person::Person{name}{}
std::string Person::getName(){ return name; }
int Student::getSemester() const { return semester; }

int main(){
    std::shared_ptr<Person> student = std::make_shared<Student>(1, "Raja");
    std::cout << student->getName() << "\n";
    std::cout << student->getSemester() <<"\n";
}
```
## Static specifier

Static specifier says the object will have a static storage duration.<br>
Only one instance of a static object exists in the program<br>
if a variable is marked as static, the space for it allocated
the first time the program control encounters its defination and deallocated when program exits.

1. Static local variable<br>
`It retains thier value across different function calls.`
```cpp
#include<iostream>
void function(){
    static int count{0};
    count++;
    std::cout << "Function ran: " << count << " times\n";
}
int main(){
    function();
    function();
    function();
    function();
    function();
}
/*
Function ran: 1 times
Function ran: 2 times
Function ran: 3 times
Function ran: 4 times
Function ran: 5 times
*/
```

2. Static class Member<br>
- In classes, static members (variables or functions) belong to the class itself rather than to any specific instance of the class.
- They are accessible through the class name and can be shared among all instances of the class.
- They have class scope, meaning they are accessible within the class and, if public, outside the class using the class name and scope resolution operator (ClassName::staticMember).

```cpp
#include<iostream>
#include<memory>
class MyClass{
    private:
        int x;
    public:
        static int objCount;
        MyClass(int xx);
        static int getObjCount();
        int getX();
};
int MyClass::objCount = 0; // Defination is required otherwise ld issue.
MyClass::MyClass(int xx) : x{xx} { objCount++; }
int MyClass::getObjCount() { return objCount; }
int MyClass::getX() { return x; }

int main(){
    std::shared_ptr<MyClass> obj0 = std::make_shared<MyClass>(0);
    std::shared_ptr<MyClass> obj1 = std::make_shared<MyClass>(1);
    std::shared_ptr<MyClass> obj2 = std::make_shared<MyClass>(2);
    std::shared_ptr<MyClass> obj3 = std::make_shared<MyClass>(3);
    std::cout << MyClass::getObjCount() << "\n";
    std::cout << MyClass::objCount << "\n";
    std::cout << obj2->getX() << "\n";
    std::cout << obj3->getObjCount() << "\n";
    std::cout << obj0->objCount << "\n";
    return 0;
}
```

3. Static global variable/function
- When static is used at the global level (outside functions and classes) for variables or functions, it limits their visibility to the file in which they are declared.
- These static global variables and functions are accessible only within the file where they are defined and are not visible outside that file.

```cpp
#include<iostream>
static float PI = 3.14f; //PI is accessible only into current file.
int main(){
    std::cout << PI <<"\n";
    return 0;
}
```
---
